# ハイパーバイザの作り方
第１５回 PCIパススルー その１「PCIパススルーとIOMMU」
はじめに
前回・前々回は、総集編として2回にわたり仮想化システムの全体像をふりかえりました。
今回は、PCIパススルーについて解説していきます。
## PCIのおさらい
PCIパススルーの解説を行う前に、まずは簡単にPCIについておさらいしましょう。

### PCIデバイスが持つID
PCIデバイスはBus Number・Device Numberで一
意に識別され、1つのデバイスが複数の機能を有する
場合はFunction Numberで個々の機能が一意に識別
されます。
　Linuxで“lspci -nn”を実行したときに出力の左端に
表示される「aa:bb:c」のうち、aaがBus Number、bbが 
Device Number、cがFunction Numberにあたります（図[fig1]）。
　さらに、そのデバイスがどこのメーカーのどの機
種であるかという情報はVendor ID・Device IDで表
され、この情報によってOSはロードするドライバ
を選びます。Linuxでlspci -nnを実行したときに出力
の右端に表示される「dddd:eeee」のうち、ddddが 
Vendor ID、eeeeがDevice IDにあたります。 
$ lspci  -nn|grep IDE
00:1f.2 IDE interface [0101]: Intel Corporation 82801JI (ICH10 Family) 4 port SATA IDE Controller #1 [8086:3a20]
00:1f.5 IDE interface [0101]: Intel Corporation 82801JI (ICH10 Family) 2 port SATA IDE Controller #2 [8086:3a26]
リスト１，lspci 実行例
PCIデバイスが持つメモリ空間
　これらのデバイスはPCI Configuration Space、PCI 
I/O Space、PCI Memory Spaceの3つのメモリ空間
を持ちます。PCI Configuration Spaceはデバイスが
どこのメーカーのどの機種であるかを示すVendor 
ID・Device IDや、PCI I/O Space・PCI Memory Space
のマップ先アドレスを示すBase Address Register、 
MSI割り込みの設定情報など、デバイスの初期化と
ドライバのロードに必要な情報を多数含んでいます。
　PCI Configuration Spaceにアクセスするには、次
のような手順を実施する必要があります。

1. デバイスのBus Number・Device Number・Function Numberとアクセスしたい領域のオフ
セット値をEnableBitとともにCONFIG_ADDRESSレジスタ[^1]にセットする
（CONFIG_ADDRESSレジスタのビット配置は表[tab1]のとおり）
2. CONFIG_DATAレジスタ[^2]に対して読み込みまたは書き込みを行う

OSはPCIデバイス初期化時に、Bus Number・Device Numberをイテレートして順に PCI Configuration SpaceのVendor ID・Device IDを参照することで、コンピュータに接続されている PCIデバイスを検出できます。
　PCI I/O SpaceはI/O空間にマップされており（図 2）、おもにデバイスのハードウェアレジスタをマッ
プするなどの用途に使われているようです[^3]。
　PCI Memory Spaceは物理アドレス空間にマップ
されており、ビデオメモリなど大きなメモリ領域を
必要とする用途に使われているようです[^4]。
　どちらの領域もマップ先は PCI Configuration SpaceのBase Address Registerを参照して取得する
必要があります。 
[^1]） 
PCではCONFIG_ADDRESSレジスタはI/O空間の0xCF8に
マップされています。
[^2]） 
PCではCONFIG_DATAレジスタはI/O空間の0xCFCにマッ
プされています。
[^3]） 
PCでは 
I/O空間にマップされますが、ほかのアーキテクチャ
ではメモリマップされる場合もあると思われます。
[^4]）必ずしもこのように使い分けられているわけではなく、ハー
ドウェアレジスタのマップに 
PCI Memory Spaceを使用する
デバイスも存在します。
表１，CONFIG_ADDRESS register
図１，PCI Configuration Space
図２，82583V GbE Controllerのパケット送信機能
PCIデバイスにおけるDMA機能
　PCIデバイスが持つメモリ空間に対して読み書き
を行うことで、 
OS上のデバイスドライバとデバイス
の間でデータをやりとりできます。具体的には、 
I/O空間に対してなら 
in/out命令を発行、物理アドレス空間ならアドレスに対して 
memcpy()のような処理を
行うことでデータを転送します。しかしながら、こ
の方法ではブロックデバイスや高速な 
NICなど、短
い時間に大量のデータを転送する用途ではデータ転
送を行う度に 
CPUが占有されてしまい、十分な性
能が得られません。このような 
PCIデバイスでは
DMA機能が使用されます。
　例として、 
82583V GbE Controller(e1000e)のパ
ケット送信機能における 
DMAの使われ方を見てみ
ましょう。図[fig3]に82583Vの送信用リングバッファ
と4種類のハードウェアレジスタ（ 
TDBA、TDLEN、 
TDH、TDT）の関係を示しました。
　TDBAはリングバッファの先頭アドレスを指しま
す。 
TDLENはリングバッファ長を示します。 
TDH
はNICがリングバッファのどこまで送信完了したか
を示します。 
TDTはドライバがリングバッファのど
こまでパケットを積んだかを示します。
　次にパケット送信の手順を示します。手順で用い
る番号は図[fig3]の番号に対応しています。
1.パケット送信処理を行う直前のレジスタおよびリ
ングバッファの状態
2.ドライバはパケットを受け取り、TDTの次のエン
トリにパケットバッファのアドレスを書き込む
3.ドライバはTDTを1つ進めて、NICへ送信可能な 
4.NICはTDTへの書き込みを受けて、パケットをメ
インメモリからNIC上のバッファへDMA転送し、
送出する。送信が終わったらTDHを1つ進めて
送信完了割り込みを起す
5.ドライバは送信完了割り込みを受け、送信済みパ
ケットバッファ（TDHより手前にあるパケットす
べて）に割り当てられたメモリを解放する
　上述の例では話をわかりやすくするため、登場す
るパケットは 
1つだけにしましたが、実際には 
NIC
の送信状況にかかわらずドライバはどんどんリング
バッファへパケットを積んでいきます[^5]。NICは順
にパケットを 
DMA転送して、送信が完了したら送
信完了割り込みを行います。ドライバが 
TDTへ書
き込んでから 
NICが送信を完了するまでの間、 
OSは
送信完了を待つ必要はありません。この間、 
OSはほ
かの処理に 
CPUの時間を使えます。送信に使った
パケットバッファを片付けるために、 
OSはNICから
の送信完了割り込みを使います。 
[^5]）ただし、リングバッファが一杯になってしまったら一時的に
送信を抑制するなどの措置をとります。
PCIデバイスのパススルー
PCI Configuration Spaceのパススルー
　ゲスト 
OSによる 
CONFIG_ADDRESSレジスタ
とCONFIG_DATAレジスタへのアクセスを 
VMExit 
Reason 30（I/O Instruction）の 
VMExitを用いて 
VMMでハンドルします[^6]。
　VMMはCONFIG_ADDRESSレジスタに設定さ
れた 
Bus Number・Device Number・Function Number
からどのデバイスへアクセスが来たのかを識別し、
パススルー対象デバイス宛てであれば、実デバイス
のConfiguration Spaceの指定オフセットへアクセス
を行います。書き込みであれば 
CONFIG_DATAレ
ジスタの値を実デバイスへ書き込み、読み込みであ
れば実デバイスから読み込んで 
CONFIG_DATAレ
ジスタから返します。
[^6]）詳しくは第 
3回 
I/O仮想化「デバイス 
I/O編」を参照。 
PCI I/O Spaceのパススルー
　ゲスト 
OSによるパススルーデバイスの 
PCI I/O Space
へのアクセスも、同じく 
VMExit Reason 30（I/O 
Instruction）のVMExitを用いて 
VMMでハンドルします。
このとき対象デバイスが持っている 
I/Oポートの範囲は 
PCI Configuration SpaceのBase Address Register
で定義されており、 
VMMはこの値を記憶しておくこと
でどのデバイスへの 
I/O命令であったか判別できます。
　VMMはゲストからデバイスのポートへ 
I/O命令
を受け、同じポートへ 
I/O命令を発行し結果をゲス
トに返します。あるいは、ゲスト側とホスト側で 
I/Oポートの番号が一致している場合[^7]は、前述の
方法をとらずに 
VMCSのVM-Execution Control 
Fieldsにある 
I/O-Bitmapで対象となるポート番号の
ビットを 
0に設定することで 
VMExitを起こさずに 
PCIデバイスへアクセスできます。 
[^7]） 
VMMが独自の 
Base Address Registerを用意しておらず、実
デバイスのものをそのままゲストに見せている場合。
PCI Memory Spaceのパススルー
　ゲスト 
OSによる 
PCI Memory Spaceへのアクセ
スは、ゲストマシンの物理メモリ空間のページ割り
当てを設定することで実現します。本連載の『第 
3回 
I/O仮想化「デバイス 
I/O編」』にて、 
EPTによるメモ
リマップド 
I/Oのハンドリング方法として、デバイ
スがマップされたアドレスへのアクセスが発生した
ときに 
VMExit reason 48（EPT violationで、 
VMExit
させる方法）を示しました[^8]。
　このように無効なページを作って 
VMExitさせる
のではなく、デバイスがマップされたページを有効
なページとして設定[^9]し、実デバイスのメモリマッ
プされたエリアをマップします。これにより、ゲス
トOSはVMExitされることなく直接実デバイスの 
PCI Memory Spaceに対してアクセスできます。
注 
8）シャドーページングのときも同じ要領で設定ができますが、
今回は解説を割愛します。
[^9]） 
Read accessビット・ 
Write accessビットをともに 
1にします。 
割り込みのパススルー
実PCIデバイスからの実割り込みはVMExit reason 1（External Interrupt）を生じさせ、 
VMMに
よって[^10]ハンドルされます。 
VMMはこの割り込みを
処理するためのパススルー専用割り込みハンドラを
あらかじめ登録しておく必要があります。割り込み
ハンドラはこの割り込みを受け付け、ゲスト 
OSへ
割り込みが届いたことを伝えるために、ゲストマシ
ンの 
Local APICレジスタを更新します。そして 
VMCSのVM-entry interruption-information fieldへ
割り込みをセットして 
VMEntryします[^11]。これによ
り、 
VMMで受け取った割り込みがゲストへ伝えら
れ、ゲスト 
OSが割り込みハンドラを実行できます。 
[^10]） 
KVM・BHyVeのようにホスト 
OS上で 
VMMが動く場合はホス
トカーネルによって違います。
[^11]）詳しい仮想割り込みのセット方法は第 
5回 
I/O仮想化「割り込
み編・その 
2」を参照。
図３，PCIパススルーでDMA転送時に生じる問題
PCIパススルーでDMA転送時に生じる問題
　ここまで、 
PCIメモリ空間や割り込みは一定の手
順を踏めばパススルーできるということを示してき
ましたが、 
DMAでは 
1つ困った問題が生じます。
　PCIデバイスは 
DMA時のアドレス指定にホスト
物理アドレスを使用します。通常、物理メモリ領域
の全域にアクセスできます。もちろん、 
PCIデバイ
スはデバイスを使用している 
OSが仮想化されてい
ることなど知りません。
　この状態で、図[fig4]のゲスト 
A上のドライバが 
DMA
先アドレスとしてゲスト物理ページの 
2番を指定す
ると何が起こるでしょうか？　 
PCIデバイスは 
DMAリクエスト元の 
OSが仮想化されていることを
知らないので、ホスト物理ページの 
2番へ 
DMA転送を行います。結果、 
PCIデバイスはゲスト 
Aのメモ
リ領域の範囲外にデータを書き込んでしまいます。
　これにより、別のゲストマシンや 
VMMのメモリ
領域を破壊してしまいます。かといって、ゲスト 
OSは自分が持つゲスト物理ページとホスト物理
ページの対応情報を持っていないので正しいページ
番号をドライバに与えられません。たとえ持ってい
たとしても、ゲスト 
OSが悪意を持ってゲストマシ
ンに割り当てられている範囲外のページ番号を指定
することで他のゲストマシンや 
VMMのメモリ領域
を破壊できるという問題が解決しません。
　そこで、物理メモリとPCIデバイスの間にMMUの
ような装置を置きアドレス変換を行う方法が考え出
されました。このような装置を 
IOMMUと呼びます。
　DMA転送時にアドレス変換を行うことで、図[fig4]の
例ではゲスト 
Aのメモリ領域の範囲外へデータを書
き込んでしまっていたパススルーデバイスが正しい
ページへデータを書き込めるようになります（図[fig5]）。
　Intel VT-dは、このような機能を実現するために
チップセットへ搭載された 
IOMMUです。 
VT-d対応 
PCでは、 
VMMがIOMMUへ変換テーブルを設定し
てアドレス変換を行い、ゲストマシンへの安全なデ
バイスパススルーを実現できます。
図４，IOMMUを用いたDMA時のアドレス変換
図 5　IOMMUを用いた DMA時のアドレス変換
まとめ
今回は、PCIのおさらいとPCIパススルーの実現方法、IOMMUについて解説しました。
次回は、Intel VT-dの詳細について解説します。ライセンス
==========

Copyright (c) 2014 Takuya ASADA. 全ての原稿データ は
クリエイティブ・コモンズ 表示 - 継承 4.0 国際
ライセンスの下に提供されています。
