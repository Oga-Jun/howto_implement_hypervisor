<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>ハイパーバイザの作り方～ちゃんと理解する仮想化技術～ 付属資料 最近のPCアーキテクチャにおける割り込みルーティングの仕組み</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title"><p>ハイパーバイザの作り方～ちゃんと理解する仮想化技術～ 付属資料 最近のPCアーキテクチャにおける割り込みルーティングの仕組み</p></h1>
</div>
<h1 id="はじめに">はじめに</h1>
<p>Linuxにおける/proc/irq/&lt;IRQ&gt;/smp_affinityはハードウェアにどのような設定を行うことにより実現されているのか、或いは最近のPCアーキテクチャにおける割り込みの仕組みはどうなっているのか、という辺りが知りたかったので調べてみた。</p>
<p>結構こんがらがっているので、予想外に時間を食ってしまった…まだ調べ尽くせていないが、一旦現時点での理解を書いておこうと思う。</p>
<h1 id="前提条件">前提条件</h1>
<ol style="list-style-type: decimal">
<li><p>2つ以上のCPUコアを持つ、Core2世代或いはCore iシリーズ世代のIntel CPU／チップセット</p></li>
<li><p>割り込みを行う主体はPCIeデバイスである（主にNICを想定しているが、これに限定されない）</p></li>
<li><p>Legacyな8259割り込みコントローラを使うことは考慮しない</p></li>
<li><p>x86_64向けLinuxカーネル（解析に使っているバージョンは3.2.0+）が動作している</p></li>
<li><p>仮想化は使用しない</p></li>
</ol>
<h1 id="pcieに於ける割り込みの種類">PCIeに於ける割り込みの種類</h1>
<h2 id="レガシー割り込みintx">レガシー割り込み（INTx）</h2>
<p>PCI規格に最初から用意されていた割り込み方法で、大半のPCIデバイスはこの割り込みを用いている。 PCIバスのメインラインとは別に用意された割り込み用の物理的なピンを用いて割り込みを通知する。</p>
<p>PCIeには割り込み用ピンは用意されておらず、帯域内メッセージを用いるレガシー割り込みエミュレーションによってソフト的な互換性を維持しているものの、基本的にはMSI／MSI-X割り込みへ移行することが推奨されているものと思われる。</p>
<h2 id="msi割り込み">MSI割り込み</h2>
<p>PCI 2.3から追加された割り込みモードでピンを使用しない帯域内メッセージで割り込みを行う。 デバイスあたり最大32個のMSIメッセージをサポートしている。</p>
<h2 id="msi-x割り込み">MSI-X割り込み</h2>
<p>PCI 3.0ではオプションとされPCIe 1.0から必須とされた割り込みモードで、MSI割り込みの拡張版。 デバイスあたり最大2048個のメッセージをサポートしている。</p>
<h1 id="割り込みルーティング">割り込みルーティング</h1>
<h2 id="レガシー割り込み">レガシー割り込み</h2>
<p>デバイスからピン経由で割り込みを通知→IOAPICでRedirection Table Entryを参照、通知先LAPICを決定→CPU内のLAPICへ割り込みを通知</p>
<h2 id="msi割り込み-1">MSI割り込み</h2>
<p>デバイスはPCI Configuration SpaceのCapability Structure内のMSIフィールドを参照、MSI AddressレジスタとMSI Dataレジスタの値から通知先LAPICとLAPIC上のベクタ番号を決定→CPU内のLAPICへ割り込みを通知</p>
<h2 id="msi-x割り込み-1">MSI-X割り込み</h2>
<p>レジスタの構成が異なる（ベクタ毎にAddressとDataが用意されている）が基本的な仕組みはMSI割り込みと同様</p>
<h2 id="capability-structure">Capability Structure</h2>
<p><span class="citation">(“BIOSがPCI Expressを初期化する手順が見えてきた:なひたふJTAG日記”)</span> を見るとイメージが分かると思うが、Configuration SpaceからLinked List状に複数のcapabilityが繋がる構造になっていて、CAPIDが0xd0なのがMSIのフィールドで、ここにはMSICTL, MSIAR, MSIDRの3つのレジスタがある。</p>
<h2 id="msi-control-registermsictl">MSI Control Register(MSICTL)</h2>
<p>どのCPUに割り込むかを考える上では重要ではないので省略</p>
<h2 id="msi-address-registermsiar">MSI Address Register(MSIAR)</h2>
<ul>
<li><p>31:20 = 0xfee</p></li>
<li><p>19:12 = Destination ID</p></li>
<li><p>11:4 = IA32では未使用</p></li>
<li><p>3 = Address Redirection Hint(RH)</p>
<ul>
<li><p>0: Directed</p></li>
<li><p>1: Redirectable</p></li>
</ul></li>
<li><p>2 = Address Destination Mode(DM)</p>
<ul>
<li><p>0: Physical Mode</p></li>
<li><p>1: Logical Mode</p></li>
</ul></li>
<li><p>1:0 = 予約</p></li>
</ul>
<p>Destination ModeがLogicalかつRedirection HintがRedirectableな場合はDestination IDでビットが立っているCPUの中でTask Priority Register(TPR)が最も低いCPUのLAPICへ割り込みが送られる。 それ以外のRH, DMの組み合わせではDestination IDで指定されているビットの中で特定のCPUのLAPICへ割り込みが送られる。</p>
<p>Physical ModeでDestination IDが0xffの場合はブロードキャスト割り込みを行う。</p>
<h2 id="msi-data-registermsidr">MSI Data Register(MSIDR)</h2>
<ul>
<li><p>31:16 = 0x0000</p></li>
<li><p>15 = Trigger mode</p>
<ul>
<li><p>0: Edge</p></li>
<li><p>1: Level</p></li>
</ul></li>
<li><p>14 = Delivery status</p>
<ul>
<li><p>0: Deassert</p></li>
<li><p>1: Assert</p></li>
</ul></li>
<li><p>13:12 = 0x00</p></li>
<li><p>11:8 = Delivery mode</p>
<ul>
<li><p>0000: Fixed</p></li>
<li><p>0001: Lowest priority</p></li>
<li><p>0010: SMI/PMI/MCA</p></li>
<li><p>0011: Reserved</p></li>
<li><p>0100: NMI</p></li>
<li><p>0101: INIT</p></li>
<li><p>0110: Reserved</p></li>
<li><p>0111: ExtINT</p></li>
<li><p>1000-1111: Reserved</p></li>
</ul></li>
<li><p>7:0 = Interrupt Vector</p></li>
</ul>
<p>Delivery modeがFixedの場合はDestinationに指定された全てのCPUへ割り込みを行う。 Lowest Priorityの場合はTask Priority Registerの値が最も低いCPUへ割り込みを行う。 Interrupt Vectorに割り込み先LAPICのVector番号を指定。</p>
<h2 id="linuxカーネルで実際にレジスタの値を設定している所を見てみる">Linuxカーネルで実際にレジスタの値を設定している所を見てみる</h2>
<p>msi_compose_msg<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>でレジスタに書き込みたい値を用意しているので、これを見てみる。 msg-&gt;address_loがMSIARレジスタで、apic-&gt;irq_dest_modeが0ならphysical mode、1ならlogical modeを設定、apic-&gt;irq_delivery_modeがdest_LowestPrioならRedirectable（MSI_ADDR_REDIRECTION_LOWPRI）を、そうでなければDirected（MSI_ADDR_REDIRECTION_CPU）を設定、変数destをDestination IDとして設定している。</p>
<p>msg-&gt;dataがMSIDRレジスタで、apic-&gt;irq_delivery_modeがdest_LowestPrioならLowest priorityを、そうでなければFixedを設定、cfg-&gt;vectorの値をInterrupt Vectorとして設定している。</p>
<p>apic-&gt;irq_dest_modeとapic-&gt;irq_delivery_modeの値はIO APICのドライバ毎に違うのだが、x86_64の標準ドライバのapic_flat_64.c<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>ではirq_dest_modeは1, irq_delivery_modeはdest_LowestPrioに設定されている。</p>
<p>これらの値は割り込み初期化時に設定され、/proc/irq/&lt;IRQ&gt;/smp_affinityの書き換え時にも維持される。 smp_affinityの書き換え時には、Destination IDとInterrupt Vectorだけが変更される<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>。</p>
<p>全ての環境でLogical modeかつLowest priorityが使えるとは限らないので、場合によってはPhysical Modeで初期化されていてsmp_affinityの値を0xffにしてもCPU0にしか割り込まないという挙動を行う事も有り得る。 実際、論理CPUが12個あるCore i7上でLinux 3.2.0+を走らせている環境ではExtended Physical Modeで初期化されていて、割り込み分散が行われていなかった。</p>
<h2 id="procirqirqsmp_affinityの書き換えでpciコンフィグレーション空間はどのように書き換わるか">/proc/irq/&lt;IRQ&gt;/smp_affinityの書き換えでPCIコンフィグレーション空間はどのように書き換わるか</h2>
<p>例えばThinkpad x200にはこんなデバイスがあります。 （dmesgから抜粋）</p>
<pre><code>e1000e: Intel(R) PRO/1000 Network Driver - 1.5.1-k
e1000e: Copyright(c) 1999 - 2011 Intel Corporation.
e1000e 0000:00:19.0: PCI INT A -&gt; GSI 20 (level, low) -&gt; IRQ 20
e1000e 0000:00:19.0: setting latency timer to 64
e1000e 0000:00:19.0: irq 44 for MSI/MSI-X
e1000e 0000:00:19.0: eth0: (PCI Express:2.5GT/s:Width x1) 00:1f:16:2a:a4:59
e1000e 0000:00:19.0: eth0: Intel(R) PRO/1000 Network Connection
e1000e 0000:00:19.0: eth0: MAC: 7, PHY: 8, PBA No: 1008FF-0FF
udev[16200]: renamed network interface eth0 to eth4</code></pre>
<p>IRQ44のMSI割り込みを一つ持つe1000eで、PCIのアドレスは00:19.0ですね。</p>
<pre><code># cat /proc/irq/44/smp_affinity
3</code></pre>
<p>CPUはcpu0とcpu1なので、全てのCPUのビットを立ててるから3。</p>
<pre><code># grep eth4 /proc/interrupts 
 44:      50037      49330   PCI-MSI-edge      eth4</code></pre>
<p>設定通り、両側のCPUに割り込んでますね。 この時、MSI Address RegisterとMSI Data Registerにはどのような値が設定されているか確認してみます。</p>
<pre><code># lspci -vvvv -s 00:19.0
00:19.0 Ethernet controller: Intel Corporation 82567LM Gigabit Network Connection (rev 03)
    Subsystem: Lenovo Device 20ee
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
    Latency: 0
    Interrupt: pin A routed to IRQ 44
    Region 0: Memory at f2600000 (32-bit, non-prefetchable) [size=128K]
    Region 1: Memory at f2625000 (32-bit, non-prefetchable) [size=4K]
    Region 2: I/O ports at 1840 [size=32]
    Capabilities: [c8] Power Management version 2
        Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)
        Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=1 PME-
    Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Address: 00000000fee0300c  Data: 41b9
    Capabilities: [e0] PCI Advanced Features
        AFCap: TP+ FLR+
        AFCtrl: FLR-
        AFStatus: TP-
    Kernel driver in use: e1000e
    Kernel modules: e1000e</code></pre>
<p>「Capabilities: [d0] MSI」の「Address」と「Data」の所ですが、これをビットフィールドと突き合わせて読まないといけません。 分かりにくいですね。 なので、lspciを改造してわかり易く表示出来るようにしてみます。</p>
<p>こちらが改造後のコード<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>になります。 早速実行してみます。</p>
<pre><code># gcc -lpci msireg.c
# ./a.out 00:19.0
Message Signalled Interrupts: 64bit+ Queue=0/0 Enable+
address_hi=0
address_lo=fee0300c dest_mode=logical redirection=lowpri dest_id=3
data=41b9 trigger=edge level=assert delivery_mode=lowpri vector=185</code></pre>
<p>Logical modeでLowpri、destid=3、vector=185になってるのが分かります。 ここでsmp_affinityを変えてみましょう。</p>
<pre><code># echo 1 &gt; /proc/irq/44/smp_affinity
# ./a.out 00:19.0
Message Signalled Interrupts: 64bit+ Queue=0/0 Enable+
address_hi=0
address_lo=fee0100c dest_mode=logical redirection=lowpri dest_id=1
data=41b9 trigger=edge level=assert delivery_mode=lowpri vector=185</code></pre>
<p>dest_idが1に書き換わったのが見て取れます。</p>
<h1 id="ライセンス">ライセンス</h1>
<p>Copyright (c) 2014 Takuya ASADA. 全ての原稿データ は クリエイティブ・コモンズ 表示 - 継承 4.0 国際 ライセンスの下に提供されています。</p>
<div class="references">
<h1>参考文献</h1>
<p>“BIOSがPCI Expressを初期化する手順が見えてきた:なひたふJTAG日記.” <a href="http://nahitafu.cocolog-nifty.com/nahitafu/2007/02/pci_express_2b63.html">http://nahitafu.cocolog-nifty.com/nahitafu/2007/02/pci_express_2b63.html</a>.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/io_apic.c#L3167">http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/io_apic.c#L3167</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/apic_flat_64.c#L180">http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/apic_flat_64.c#L180</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/io_apic.c#L3201">http://lxr.linux.no/linux+v3.2/arch/x86/kernel/apic/io_apic.c#L3201</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://gist.github.com/1568777">https://gist.github.com/1568777</a><a href="#fnref4">↩</a></p></li>
</ol>
</div>
</body>
</html>
