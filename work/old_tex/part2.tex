\input{preamble}
\title{ハイパーバイザの作り方～ちゃんと理解する仮想化技術～ 第２回 Intel VT-xの概要とメモリ仮想化}
\author{Takuya ASADA syuu@dokukino.com}
\begin{document}
\maketitle

\section{VMCSの構造}
それでは、前回のハイパーバイザのライフサイクルの説明でも度々紹介したハイパーバイザ側のコンフィグレーション情報であるVMCS（Virtual Machine Control Structure）の内部構造（図\ref{fig1}）を以下に説明します。

\begin{figure}\centering
\includegraphics{figures/part2_fig1.eps}
\caption{VMCSの内部構造}
\label{fig1}
\end{figure}

\subsection*{VMCS revision identifier}
VMCS のデータフォーマットのリビジョン番号。VT-x が拡張され、古いCPUと新しいCPUではVMCS のフォーマットが異なる可能性があるため、バージョンチェックのためリビジョンが書き込まれる。ハイパーバイザでサスペンド／レジュームやマイグレーションを実装する時に異なるIntel CPU間でVMCSをセーブ／ロードした時に不整合が発生するのを防ぐことを意図している

\subsection*{VMCS-abort indicator}
VMExit 中にエラーが発生し、正常にVMExit 要因などのデータがVMCS へ書き込めなかった場合、エラーコードがここに書き込まれる。「VMExit が失敗した場合」なので、正常に動作している限りは使われない

\subsection*{VMCS data}
VMCS の本体部分で、通常はこの領域のいずれかのフィールドを読み書きする

\subsection*{Guest-state area}
VMExit 時にゲストのレジスタを退避し、VMEntry 時に復帰するための領域です。次のレジスタが保存の対象：

CR0, CR3, CR4, DR7, RSP, RIP, RFLAGS, CS, SS, DS, ES, FS, GS, LDTR, TR, GDTR, SMBASE

また、以下のMSRレジスタが保存の対象：

IA32\_DEBUGCTL, IA32\_SYSENTER\_CS, IA32\_SYSENTER\_ESP, IA32\_SYSENTER\_EIP,IA32\_PERF\_GLOBAL\_CTRL, IA32\_PAT, IA32\_EFER

さらに、レジスタ以外のステートとして、仮想CPU の状態・各セグメントの状態や属性・割り込みブロック状態の有無・VMX プリエンプションタイマのカウンタ・EPT のPTE アドレス等の情報も記録されている。

ここで保存の対象になっていないレジスタについてはハイパーバイザが退避と復帰を行う必要がある

\subsection*{Host-state area}
VMEntry 時にハイパーバイザのレジスタを退避し、VMExit 時に復帰するための領域。次のレジスタが
保存の対象になっている：

CR0, CR3, CR4, RSP, RIP, CS, SS, DS, ES, FS, GS, LDTR, TR, GDTR

また、以下のMSRレジスタが保存の対象になっている：

IA32\_SYSENTER\_CS, IA32\_SYSENTER\_ESP, IA32\_SYSENTER\_EIP, IA32\_PERF\_GLOBAL\_CTRL,IA32\_PAT, IA32\_EFER

ここで保存の対象になっていないレジスタについては、ハイパーバイザが退避と復帰を行う必要がある

\subsection*{VM-execution control fields}
ゲストマシン実行時のCPU の挙動を設定するエリア。どのようなイベントでVMExit するかという情報はここに含まれている。各種のVMExit 要因のオン／オフフラグの他、EPT（メモリ仮想化支援）のオン／オフフラグ、EPT のアドレス、仮想Local APIC の設定、VPID のアドレスなどが含まれる

\subsection*{VM-exit control fields}
VMExit 時のCPU の挙動を設定するエリア。外部割り込み要因でVMExitしたときのCPUの挙動や、いくつかのMSR を退避・復帰機能のオン／オフフラグ、ハイパーバイザの64モードのオン／オフフラグなどが含まれる

\subsection*{VM-entry control fields}
VMEntry 時のCPU の挙動を設定する。ゲストマシンへの割り込み挿入のフィールドやいくつかのMSR の復帰機能のオン／オフフラグなど、ゲストの64bitモードのオン／オフフラグなどが含まれる

\subsection*{VM-exit information fields}
VMExit 時のexit 要因がここに書き込まれる

\section{VMExit要因}
VT-xではリスト1のような要因によるVMExitを発生させることができます。これらの要因でVMExitを発生させるかどうかはVMCS上の「VM-execution control fields」で設定し、発生した場合VMCS上の「VM-exit information fields」に書き込まれます。

\subsection*{リスト１　VMExit要因}
\begin{itemize}
 \item 例外かNMI割り込みの発生
 \item 外部割り込みの発生
 \item トリプルフォールト
 \item INITシグナルの受信
 \item SIPIの受信
 \item SMIの受信
 \item 内部割り込みの発生
 \item タスクスイッチ
 \item CPUID命令の実行
 \item Intel SMX 関連の命令の実行
 \item HLT命令の実行
 \item キャッシュ関連の命令の実行（INVD, WBINVD）
 \item TLB関連の命令の実行（HNVLPG, INVPCID）
 \item I/O関連の命令の実行（INB,OUTBなど）
 \item パフォーマンスモニタリングカウンタ関連の命令の実行（RDPMC）
 \item タイムスタンプカウンタ関連の命令の実行（RDTSC）
 \item SMM関連の命令の実行（RSM）
 \item VT-x拡張命令セットの実行
 \item コントロールレジスタへのアクセス
 \item 拡張コントロールレジスタへのアクセス
 \item デバッグレジスタへのアクセス
 \item MSRへのアクセス
 \item MONITOR/MWAIT 命令の実行
 \item PAUSE 命令の実行
 \item APICレジスタへのアクセス
 \item GDTR、IDTR、LDTR、TRレジスタへのアクセス
 \item VMXプリエンプションタイマのエクスパイヤ
 \item RDRAND命令の実行
\end{itemize}

\section{VT-x 拡張命令セット}
ハイパーバイザからVT-xの機能へアクセスするために、次のような命令が追加されています（ただし、VMCALLとVMFUNCについてはゲストマシンから呼ばれることが想定されています）。各命令のさらに詳しい説明については\cite{SDM}を参照してください。

\subsection*{VMCSメンテンナンス命令}
VMCS内のデータは普通のメモリアクセス命令で読み書きするのではなく、VMREAD/VMWRITEを経由する必要があります。ゲストマシン起動時の手順は、VMPTRLDでVMCSのアドレスを設定、VMCLEARで初期化、VMWRITEでフィールドへ初期値を書き込んでからVMEntryとなります。

\subsection*{VT-x管理命令}
ハイパーバイザ上で一連のVT-x拡張命令セットを利用するには、まずVMXONを実行する必要があります。VMX non Root ModeへVMEntryするには、初めてVMEntryするときだけVMLAUNCH、以降VMExitから復帰するときはVMRESUMEとなります。

\subsection*{ハイパーコール命令}
ゲストマシンからハイパーバイザを呼び出して何らかの処理を依頼するための命令です。準仮想化を実現するために使われることがあります。EPT操作命令メモリアクセスの仮想化支援（EPT）が有効なハイパーバイザで使われる命令です。EPTについては後述します。

\subsection*{ページングとメモリの仮想化}
マルチタスクをサポートする近代的なOSでは、プロセスごとに独立したメモリ空間を持ち、あるプロセスは別のプロセスのメモリ領域へアクセスできないようになっています。

これを実現するために、CPUに「仮想メモリ」をサポートする機構（MMU）が搭載されています((別の方式としてセグメント方式というものがあり、x86アーキテクチャはこの方式からページング方式へ移行してきたという歴史的事情があるため、今でもセグメント方式をサポートしています。))。

仮想メモリの実現方法として、現在では一般的に「ページング方式」がとられています。この方式では、プロセスごとの仮想メモリ空間を固定長（x86アーキテクチャでは一般的に4KB）に区切り、仮想ページと物理ページの割り当て情報を「ページテーブル」と呼ばれるメモリ上の表に記録します（図\ref{fig2}）。

\begin{figure}\centering
\includegraphics{figures/part2_fig2.eps}
\caption{ページテーブル}
\label{fig2}
\end{figure}

CPUからメモリへのアクセスがあった時、MMUはページテーブルを用いて仮想アドレスを物理アドレスへ変換し、適切な物理メモリアドレスへのアクセスを可能にします。

ページテーブル上の各ページに対するエントリには対応する物理ページの情報以外にも、アクセス権（読み／書き／実行）のような属性情報が存在します。

これによって特定のメモリ範囲に対してアクセス制御を行うようなことができます。

また、アクセスの少ない物理ページをディスクへ書き出しページテーブル上の割り当て情報を解除（ページアウト）します。そして後にアクセスが起こったときにディスクから読み込んでページテーブル上の割り当て情報を再設定（ページイン）することで、物理メモリ容量よりも大きな仮想メモリを扱うことができるようになります。

仮想化されたシステムにおいて、CPU上でそのままゲストOSを実行する時、このページング機構を仮想化する必要が生じます。これは、ゲストOS上のプロセスに割り当てられた仮想ページの参照先である物理ページのアドレスが指しているのはハイパーバイザがゲスト環境へ割り付けたメモリ領域内のアドレスであり、ハイパーバイザが管理する物理メモリ空間上のアドレスではないからです。

たとえば、仮想マシンAへ1から4まで、仮想マシンBへ5から8までの物理ページを割り当てたとします。それぞれの仮想マシン上の物理ページ1へアクセスが行われる時、実際には仮想マシンAからであれば物理ページ1へ、仮想マシンBからであれば物理ページ5へアクセスが行われなければなりません（図\ref{fig3}）。

\begin{figure}\centering
\includegraphics{figures/part2_fig3.eps}
\caption{メモリの仮想化による問題}
\label{fig3}
\end{figure}

この問題を解決するメモリ仮想化の手法として、ソフトウェアによる「シャドーページング」、ハードウェアによる「EPT」の2つを紹介します。

\section{x86アーキテクチャにおけるページング機構}
まず、x86アーキテクチャにおけるページング機構について、簡単におさらいしましょう。x86アーキテクチャでは1ページのサイズは4KBであるため、32bitモードでのページ総数は1,048,576ページとなります。このページテーブルを単純な2次元の表として表すと消費メモリ量が大きくなってしまいます。

そこで、x86アーキテクチャではページディレクトリテーブルという概念を導入しました。これにより、少ないサイズでページテーブルを表現しています。1 つのページテーブルは1024エントリとし、1つのページテーブルに4MBの仮想メモリ空間の情報を持たせます。

ページディレクトリテーブルは、このページテーブルのアドレス情報を格納します。ページディレクトリテーブルは1024 エントリあり、4GBの仮想メモリ空間全体を表現しています（図\ref{fig4}）。

\begin{figure}\centering
\includegraphics{figures/part2_fig4.eps}
\caption{仮想メモリ空間のページング2段構成}
\label{fig4}
\end{figure}

64bitモードの場合は8バイトのページテーブルエントリがテーブル当たり512エントリとなり、さらにページディレクトリポインタテーブルとページマップレベル4テーブルの2段が追加されて256TBの仮想メモリ空間をサポートしています\footnote{32bit PAEモードの場合も64bitモードのように段数が追加されて仮想メモリ空間が拡張されますが、ここでは解説を省略します。}（図\ref{fig5}）。

\begin{figure}\centering
\includegraphics[width=1.0\textwidth]{figures/part2_fig5.eps}
\caption{64bitモードの仮想メモリ空間}
\label{fig5}
\end{figure}

複数段にするだけではページテーブルの総エントリ数は変わりません。しかし、未使用の仮想メモリ空間も発生するため、必要な仮想メモリ空間に対してのみページテーブルを作成すれば、その分消費メモリを抑えることができます。

ページディレクトリテーブルのアドレスをCPUにセットするためのレジスタとしてCR3レジスタが用意されています。MMUは仮想メモリ空間へのアクセスに対してCR3レジスタに書かれたページディレクトリテーブルのアドレスへアクセスして探索を行います。探索を行う時、仮想アドレスの先頭10ビットをページディレクトリテーブルへのオフセットとしてページテーブルを指すエントリを探索します。

ページテーブルでは仮想アドレスの11～20ビットをオフセットとして物理ページを指すエントリを探索します。見つかった物理ページのアドレスに対して仮想アドレスの残り12ビットの値を足したアドレスが、CPUがアクセスしようとしている物理アドレスとなります。

ページディレクトリテーブル／ページテーブルの各エントリにはページテーブル／物理ページのアドレスだけでなく、いくつかの属性情報が含まれます。

次にその詳細を示します。

\begin{itemize}
 \item プレゼントビット……1なら物理メモリ上に存在、0ならページフォルト例外
 \item リードライトビット……0の時に書き込みが実行されたらページフォルト例外
 \item ユーザスーパーバイザービット……0ならRing3からアクセス禁止
 \item ページライトスルービット……0ならライトスルー、1ならライトバック
 \item ページキャッシュディスエーブルビット……1ならキャッシュ禁止
 \item アクセスビット……ページにアクセスした時にCPUが1にする
 \item ダーティービット……ページに書き込んだ時にCPUが1にする
 \item PATビット……ページでPATを有効にする
 \item グローバルビット……1ならグローバルなページ、TLBの挙動に影響する
 \item ベースアドレス（20ビット）……ページディレクトリテーブルの場合はページテーブルのアドレス、ページテーブルの場合は物理ページのアドレス
\end{itemize}

64bitモードの場合は、ベースアドレス長を拡張するためにページテーブルエントリが64bitへ拡張されます。たとえば、物理メモリの空き容量が低下した等の理由でページアウトを行う時は、物理ページをディスクへ書き出した後、プレゼントビットを0に設定します。ページアウトされた仮想ページへCPUがアクセスした場合、ページフォルト例外が発生します。ページフォルト例外のハンドラは、ディスクからページアウトされたページをメモリへロードし、ページテーブルのエントリへ新しい物理ページのベースアドレスを書き込み、プレゼントビットを有効にします。

他には、カーネルモードとユーザモードでページテーブルを共有する場合、カーネルの領域をユーザスーパーバイザービット＝0にしておき、ユーザの領域をユーザスーパーバイザービット＝1にしておくという使い方をすることで、ユーザモードプログラムからカーネルのメモリ領域へアクセスされることを防ぎつつページテーブルの共有を可能にすることができます。ページングについてのより詳細な情報を得るには、\cite{SDM}のChapter 4. Pagingを参照してください。

\section{シャドーページング}
ゲストOSが各プロセスに対して作成したページテーブルとページディレクトリテーブルをそのまま実際のCPUのCR3レジスタに設定すると、現実の物理メモリ空間が参照されてしまいます。これではハイパーバイザが意図しないメモリ領域を参照することになってしまいます。これを防ぐため、ハイパーバイザはゲストのページディレクトリテーブルとページテーブルを複製し、ハイパーバイザがゲストマシンに割り当てたメモリ範囲を反映した物理ページ番号をページテーブルの各エントリに書き込み、CPUのCR3レジスタに複製したページディレクトリテーブルを書き込みます（図\ref{fig6}）。

\begin{figure}\centering
\includegraphics{figures/part2_fig6.eps}
\caption{シャドーページング}
\label{fig6}
\end{figure}

これにより、ゲストマシンの実行時に仮想ページへアクセスが生じた時、ゲストOSが設定したゲストマシン内の物理ページ番号ではなく、ハイパーバイザが設定した実際の物理ページ番号を参照するようになります。以上により適切なメモリ領域へ参照が行えるようになります。

\section{EPT}
Nehalem以降のIntelのCPUでは、メモリ仮想化をCPUで支援する機能である「EPT」が追加されました。EPTをゲストマシンで有効にするには、64bitモードにおけるページングと同様に4段のページテーブルを作成し、ゲスト物理アドレスからホスト物理アドレスへのマッピング情報を書き込み、VMCSのVM Execution control fieldにあるExtended Page Table Pointer（EPTP）にページマップレベル4テーブルのアドレスをセットします。

これにより、ゲストマシンから仮想メモリ空間への参照が行われた時に、CR3にセットされたページテーブルでゲスト物理アドレスへの変換が行われます。さらにEPTPにセットされたページテーブルでゲスト物理アドレスからホスト物理アドレスへの変換が行われます（図\ref{fig7}）。

\begin{figure}\centering
\includegraphics[width=1.0\textwidth]{figures/part2_fig7.eps}
\caption{ゲスト物理アドレスからホスト物理アドレスへの変換}
\label{fig7}
\end{figure}

シャドーページングの場合は、CR3レジスタやページテーブルエントリへの読み書きのたびにシャドーページテーブルを構築していました。このときにVMExitが発生し、オーバヘッドとなっていましたが、EPTではこの処理が省かれることにより、パフォーマンスが向上します((ハイパーバイザの実装によっては30％ほど高速化すると言われています。))。

EPTのページテーブルエントリは、通常のページテーブルエントリとフィールドの割り当てが異なります。

\section{VPID}
直接EPTに関連する機能ではありませんが、メモリに関連するハードウェア仮想化支援機能でEPTとともにNehalem以降のIntelのCPUへ導入された「VPID（Virtual Processor Identifier）」を解説します。

アドレス変換を高速化するため、CPUにはページテーブルエントリをキャッシュするTLBという機構が搭載されています。これは、仮想アドレスと物理アドレスのペアを記憶する連想メモリ（CAM）であり、少数の頻繁にアクセスされる領域をキャッシュします。

また、ページテーブルエントリが書き換えられた時やページテーブルが切り替えられた時に「フラッシュ」操作を行い、エントリを削除してページテーブルとの整合性を保ちます。

ゲストマシンをVMExitしてホストOSでプロセスを実行したり、別のゲストマシンを実行する時、TLBをフラッシュしないと仮想アドレスのアドレス解決が誤動作を起こします。このため、初期のVT-x対応CPUではVMEntry時／VMExit時にTLBをすべてフラッシュする必要がありました。

Nehalem以降のIntelのCPUでは、これを防いでパフォーマンスを向上させる機能としてVPIDが導入されました。VPIDを有効にするには、VMCSのVM Execution control fieldにあるVPIDフィールドにそのゲストマシンのユニークなIDを設定します。

VPID有効時には、VMEntry時／VMExit時にINVVPID命令により直前に実行していたゲストマシンのエントリのみTLBからフラッシュできるようになります。

\section{まとめ}
いかがでしたでしょうか。今回は、前回の解説を補足するためにVMCSとVT-x命令セットの解説を行い、さらにメモリ仮想化について見てきました。

次回は「I/Oの仮想化」について解説します。

\section*{謝辞}
校正に関して協力してくださった金子 直矢さん、水野 貴史さん、太居 司さん、忠鉢 洋輔さんありがとうございました。

\section*{ライセンス}
Copyright (c) 2014 Takuya ASADA.
全ての原稿データ は クリエイティブ・コモンズ 表示 - 継承 4.0 国際 ライセンスの下に提供されています。

\begin{thebibliography}{4}
  \bibitem{SDM} Intel(R) 64 and IA-32 Architectures Software Developer Manuals \url{http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html/}
\end{thebibliography}

\end{document}
